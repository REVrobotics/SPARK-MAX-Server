syntax = "proto3";

package sparkusb;

/* Interface functions for service sparkusb.
* All command requests are serialized into a 
* RequestWire type before transmission, and
* Deserializezd to a ResponseWire on recipt
*/
service sparkusb {
    /*
    * Connect to the requested serial port. If no port
    * is provided, connect to the default port, which is 
    * the first port found with a SPARK device.
    */
    rpc Connect(controlRequest) returns (controlResponse) {}

    /*
    * Disconnect the serial port
    */
    rpc Disconnect(controlRequest) returns (controlResponse) {}

    /*
    * Ping the SPARK to verify connection to the hardware and to
    * this server.
    */
    rpc Ping(controlRequest) returns (controlResponse){}

    /*
    * List the serial port information for all connected
    * SPARK devices.
    */
    rpc List(listRequest) returns (listResponse) {}

    /*
    * Update the firmware of the device
    */
    //rpc Firmware(firmwareRequest) returns (firmwareResponse) {}

    /*
    * Send a Heartbeat to the SPARK device (similar to how the roboRIO
    * heartbeat to the device over CAN). This message can be simplified
    * if driving the motor by calling Setpoint({Enable: true})
    */
    rpc Heartbeat(heartbeatRequest) returns (rootResponse) {}

    /*
    * Change the SPARK address. Currently done through SetParameter()
    */
    //rpc Address(addressRequest) returns (addressResponse) {}

    /*
    * Set a device parameter. The parameter should be configParam type
    * the value is a string in both the request and response.
    */
    rpc SetParameter(parameterRequest) returns (parameterResponse) {}

    /*
    * Get a device parameter. The parameter should be configParam type
    * the value returned is a string in both the request and response.
    * The requested value type is also passed to help decode. The type
    * is of type paramType
    */
    rpc GetParameter(parameterRequest) returns (parameterResponse) {}

    /*
    * Make all configuration changes permanent for the next time the 
    * device powers on. Note: This writes any values that have changed
    * and can only be called when the device is not enabled. Since this
    * method writes directly to FLASH, avoid calling frequently, as each
    * flash location can be written to a total of 10,000 times in its lifetime.
    * Flash wear leveling is being implemented and should be in the release
    * before kickoff
    */
    rpc BurnFlash(burnRequest) returns (burnResponse) {}

    /*
    * Return a list of all available parameters with their name, number, and type
    */
    //rpc ListParameters(parameterListRequest) returns (parameterListResponse) {}

    /*
    * Send a setpoint command. The value should be native units depending
    * on the curernt control mode (+/- 1.0 for duty cycle control)
    * Setting Enable = true will also send a heartbeat allowing the controller
    * drive the motor.
    */
    rpc Setpoint(setpointRequest) returns (setpointResponse) {}

    /*
    * Set controller to follow another controller.
    */
    rpc Follow(followerRequest) returns (rootResponse) {}
}

/*
* Data format to send over 0mq containing one request
*/
message RequestWire {
    oneof req {
        rootCommand             root = 10;
        commandLineRequest      cmdLine = 11;
        listRequest             list = 12;
        firmwareRequest         firmware = 13;
        heartbeatRequest        heartbeat = 14;
        addressRequest          address = 15;
        parameterRequest        parameter = 16;
        parameterListRequest    parameterList = 17;
        setpointRequest         setpoint = 18;
        controlRequest          control = 19;
        followerRequest         follower = 20;
        burnRequest             burn = 21;
    }
}

/*
* Data format to recieve over 0mq containting one response
*/
message ResponseWire {
    oneof resp {
        rootResponse            root = 10;
        commandLineResponse     cmdLine = 11;
        listResponse            list = 12;
        firmwareResponse        firmware = 13;
        addressResponse         address = 14;
        parameterResponse       parameter = 15;
        parameterListResponse   parameterlist = 16;
        setpointResponse        setpoint = 17;
        controlResponse         control = 18;
        burnResponse            burn = 19;
    }
}

/*
* Types of control message to send
*/
enum controlMessage {
    controlPing = 0;
    controlConnect = 1;
    controlDisconnect = 2;
}

/*
* Request format for connect() disconnect() and ping()
*/
message controlRequest {
    controlMessage ctrl = 1;
    string device = 2;
}

/*
* Burn command
*/
message burnRequest {
    rootCommand root = 1;
    bool verify = 2;
}


message burnResponse {    
    rootResponse root = 1;
    bool verify = 2;
}

/*
* Response format for connect() disconnect() and ping()
*/
message controlResponse {
    bool connected = 1;
}


message commandLineRequest {
    string stdin = 1;
}

message commandLineResponse {
    string stderr = 1;
    string stdout = 2;
}

/*
* All RPC services implement this request
* keepalive and help are not implemented
*/
message rootCommand {
    string device = 1;
    bool keepalive = 2;
    bool help = 3;
}

/*
* All RPC services implement this response
* helpString not implemented
*/
message rootResponse {
    string helpString = 1;
    string error = 2;
}

/*
* Request format for list() command
*/
message listRequest {
    rootCommand root = 1;
    bool all = 2; 
}

/*
* Response format for list() command
*/
message listResponse {
    repeated string deviceList = 1;
    repeated string deviceDetails = 2;
    rootResponse root = 3;
}

/*
* Request format for firmware() command
*/
message firmwareRequest {
    rootCommand root = 1;
    string filename = 2;
}

/*
* Response format for list() command
*/
message firmwareResponse {
    string version = 1;
    rootResponse root = 3;
}

/*
* Request format for heartbeat() command
*/
message heartbeatRequest {
    rootCommand root = 1;
    bool enable = 2;
}

/*
* Request format for address() command
*/
message addressRequest {
    rootCommand root = 1;
    uint32 address = 2;
}

/*
* Response format for address() command
*/
message addressResponse {
    uint32 currentAddress = 1;
    uint32 previousAddress = 2;
    rootResponse root = 3;
}

/*
* Parameter ID for set/get parameter fields
* these values match the SPARK firmware
* @omit THIS ENUM IS AUTO GENERATED FROM SPREADSHEET
*/
enum configParam {
    /*
    * CAN ID
    * @default 0
    * @type uint
    */
    kCanID = 0;

    /*
    * Input mode, this parameter is read only and the input mode is detected by t
    * he firmware automatically, results are %Input Mode%
    * @default 0
    * @type Input Mode
    */
    kInputMode = 1;

    /*
    * Motor Type, options are %Motor Type%
    * @default BRUSHED
    * @type Motor Type
    */
    kMotorType = 2;

    /*
    * Electrical degree of offset from the backemf crossing to commutation for se
    * nsorless modes. This is currently not implemented
    * @default 0
    * @type float32
    * @unit Degrees
    */
    kCommAdvance = 3;

    /*
    * Sensor Type, options are %Sensor Type%
    * @default HALL_SENSOR
    * @type Sensor Type
    */
    kSensorType = 4;

    /*
    * Control Type, this is a read only parameter of the currently active control
    *  type. Options are %Ctrl Type%
    * @default CTRL_DUTY_CYCLE
    * @type Ctrl Type
    */
    kCtrlType = 5;

    /*
    * State of the half bridge when the motor controller commands zero output or 
    * is disabled. Options are %Idle Mode%
    * @default IDLE_COAST
    * @type Idle Mode
    */
    kIdleMode = 6;

    /*
    * Percent of the input which results in zero output
    * @default 0.05
    * @type float32
    * @unit Percent
    */
    kInputDeadband = 7;

    /*
    * Read only parameter showing the 32-bit firmware version. The first byte is 
    * the major build, the second byte is in the minor build, the last two bytes
    *  are the build
    * @default 0
    * @type Firmware
    */
    kFirmwareVer = 8;

    /*
    * Electrical offset of the hall sensor compared to the motor phases in degree
    * s. Typically this is either 0, 60, 120
    * @default 0
    * @type int
    * @unit Degrees
    */
    kHallOffset = 9;

    /*
    * Number of pole pairs for the brushless motor. This is the number of poles/2
    *  and can be determined by either counting the number of magents or countin
    * g the number of windings and dividing by 3. This is an important term for 
    * speed regulation to properly calculate the speed
    * @default 1
    * @type uint
    */
    kPolePairs = 10;

    /*
    * If the half bridge detects this current limit, it will disable the motor dr
    * iver until the current goes below a certain threshold before enabling. Thi
    * s is a low sophistication 'current control'
    * @default 0
    * @type float32
    * @unit Amps
    */
    kCurrentChop = 11;

    /*
    * If the half bridge detects this current limit, it will disable the motor dr
    * iver and report a sticky fault. The motor driver will not enable again unt
    * il this fault is cleared.
    * @default 0
    * @type float32
    * @unit Amps
    */
    kCurrentLimit = 12;

    /*
    * Perportional gain constant for gain slot 0. In cascaded control modes this 
    * is the inner loop gain slot 0.
    * @default 0
    * @type float32
    */
    kP_0 = 13;

    /*
    * Integral gain constant for gain slot 0. In cascaded control modes this is t
    * he inner loop gain slot 0.
    * @default 0
    * @type float32
    */
    kI_0 = 14;

    /*
    * Derivative gain constant for gain slot 0. In cascaded control modes this is
    *  the inner loop gain slot 0.
    * @default 0
    * @type float32
    */
    kD_0 = 15;

    /*
    * Feed Forward gain constant for gain slot 0. In cascaded control modes this 
    * is the inner loop gain slot 0.
    * @default 0
    * @type float32
    */
    kF_0 = 16;

    /*
    * Integrator zone constant for gain slot 0. The PIDF loop integrator will onl
    * y accumulate while the setpoint is within IZone of the target. In cascaded
    *  control modes this is the inner loop gain slot 0.
    * @default 0
    * @type float32
    */
    kIZone_0 = 17;

    /*
    * PIDF derivative filter constant for gain slot 0. In cascaded control modes 
    * this is the inner loop gain slot 0.
    * @default 0
    * @type float32
    */
    kDFilter_0 = 18;

    /*
    * Max output constant for gain slot 0. This is the max output of the controll
    * er as well as the max integrator value. In cascaded control modes this is 
    * the inner loop gain slot 0.
    * @default 0
    * @type float32
    */
    kOutputMin_0 = 19;

    /*
    * Min output constant for gain slot 0. This is the min output of the controll
    * er as well as the min integrator value. In cascaded control modes this is 
    * the inner loop gain slot 0.
    * @default 0
    * @type float32
    */
    kOutputMax_0 = 20;

    /*
    * Perportional gain constant for gain slot 1. In cascaded control modes this 
    * is the inner loop gain slot 1.
    * @default 0
    * @type float32
    */
    kP_1 = 21;

    /*
    * Integral gain constant for gain slot 1. In cascaded control modes this is t
    * he inner loop gain slot 1.
    * @default 0
    * @type float32
    */
    kI_1 = 22;

    /*
    * Derivative gain constant for gain slot 1. In cascaded control modes this is
    *  the inner loop gain slot 1.
    * @default 0
    * @type float32
    */
    kD_1 = 23;

    /*
    * Feed Forward gain constant for gain slot 1. In cascaded control modes this 
    * is the inner loop gain slot 1.
    * @default 0
    * @type float32
    */
    kF_1 = 24;

    /*
    * Integrator zone constant for gain slot 1. The PIDF loop integrator will onl
    * y accumulate while the setpoint is within IZone of the target. In cascaded
    *  control modes this is the inner loop gain slot 1.
    * @default 0
    * @type float32
    */
    kIZone_1 = 25;

    /*
    * PIDF derivative filter constant for gain slot 1. In cascaded control modes 
    * this is the inner loop gain slot 1.
    * @default 0
    * @type float32
    */
    kDFilter_1 = 26;

    /*
    * Max output constant for gain slot 1. This is the max output of the controll
    * er as well as the max integrator value. In cascaded control modes this is 
    * the inner loop gain slot 1.
    * @default 0
    * @type float32
    */
    kOutputMin_1 = 27;

    /*
    * Min output constant for gain slot 1. This is the min output of the controll
    * er as well as the min integrator value. In cascaded control modes this is 
    * the inner loop gain slot 1.
    * @default 0
    * @type float32
    */
    kOutputMax_1 = 28;

    /*
    * Perportional gain constant for gain slot 3. In cascaded control modes this 
    * is the outer loop gain slot 0.
    * @default 0
    * @type float32
    */
    kP_2 = 29;

    /*
    * Integral gain constant for gain slot 3. In cascaded control modes this is t
    * he outer loop gain slot 0.
    * @default 0
    * @type float32
    */
    kI_2 = 30;

    /*
    * Derivative gain constant for gain slot 3. In cascaded control modes this is
    *  the outer loop gain slot 0.
    * @default 0
    * @type float32
    */
    kD_2 = 31;

    /*
    * Feed Forward gain constant for gain slot 3. In cascaded control modes this 
    * is the outer loop gain slot 0.
    * @default 0
    * @type float32
    */
    kF_2 = 32;

    /*
    * Integrator zone constant for gain slot 3. The PIDF loop integrator will onl
    * y accumulate while the setpoint is within IZone of the target. In cascaded
    *  control modes this is the outer loop gain slot 0.
    * @default 0
    * @type float32
    */
    kIZone_2 = 33;

    /*
    * PIDF derivative filter constant for gain slot 3. In cascaded control modes 
    * this is the outer loop gain slot 0.
    * @default 0
    * @type float32
    */
    kDFilter_2 = 34;

    /*
    * Max output constant for gain slot 3. This is the max output of the controll
    * er as well as the max integrator value. In cascaded control modes this is 
    * the outer loop gain slot 0.
    * @default 0
    * @type float32
    */
    kOutputMin_2 = 35;

    /*
    * Min output constant for gain slot 3. This is the min output of the controll
    * er as well as the min integrator value. In cascaded control modes this is 
    * the outer loop gain slot 0.
    * @default 0
    * @type float32
    */
    kOutputMax_2 = 36;

    /*
    * Perportional gain constant for gain slot 4. In cascaded control modes this 
    * is the outer loop gain slot 1.
    * @default 0
    * @type float32
    */
    kP_3 = 37;

    /*
    * Integral gain constant for gain slot 4. In cascaded control modes this is t
    * he outer loop gain slot 1.
    * @default 0
    * @type float32
    */
    kI_3 = 38;

    /*
    * Derivative gain constant for gain slot 4. In cascaded control modes this is
    *  the outer loop gain slot 1.
    * @default 0
    * @type float32
    */
    kD_3 = 39;

    /*
    * Feed Forward gain constant for gain slot 4. In cascaded control modes this 
    * is the outer loop gain slot 1.
    * @default 0
    * @type float32
    */
    kF_3 = 40;

    /*
    * Integrator zone constant for gain slot 4. The PIDF loop integrator will onl
    * y accumulate while the setpoint is within IZone of the target. In cascaded
    *  control modes this is the outer loop gain slot 1.
    * @default 0
    * @type float32
    */
    kIZone_3 = 41;

    /*
    * PIDF derivative filter constant for gain slot 4. In cascaded control modes 
    * this is the outer loop gain slot 1.
    * @default 0
    * @type float32
    */
    kDFilter_3 = 42;

    /*
    * Max output constant for gain slot 4. This is the max output of the controll
    * er as well as the max integrator value. In cascaded control modes this is 
    * the outer loop gain slot 1.
    * @default 0
    * @type float32
    */
    kOutputMin_3 = 43;

    /*
    * Min output constant for gain slot 4. This is the min output of the controll
    * er as well as the min integrator value. In cascaded control modes this is 
    * the outer loop gain slot 1.
    * @default 0
    * @type float32
    */
    kOutputMax_3 = 44;

    /*
    * Reserved
    * @default 0
    * @type uint
    */
    kReserved = 45;

    /*
    * Simple scalar for all units in all closed loop control modes to scale units
    *  to native. Use this to scale the output to things like gear ratios or uni
    * t conversions
    * @default 1
    * @type float32
    */
    kOutputRatio = 46;

    /*
    * Low 32-bits of unique 96-bit serial number
    * @default 0
    * @type uint
    */
    kSerialNumberLow = 47;

    /*
    * Middle 32-bits of unique 96-bit serial number
    * @default 0
    * @type uint
    */
    kSerialNumberMid = 48;

    /*
    * High 32-bits of unique 96-bit serial number
    * @default 0
    * @type uint
    */
    kSerialNumberHigh = 49;

    /*
    * Limit switch polarity. Default is Normally Open (1), and can be set to Norm
    * ally Closed (0)
    * @default 1
    * @type bool
    */
    kLimitSwitchFwdPolarity = 50;

    /*
    * Limit switch polarity. Default is Normally Open (1), and can be set to Norm
    * ally Closed (0)
    * @default 1
    * @type bool
    */
    kLimitSwitchRevPolarity = 51;

    /*
    * Limit switch enable, disabled by default
    * @default 0
    * @type bool
    */
    kHardLimitFwdEn = 52;

    /*
    * Limit switch enable, disabled by default
    * @default 0
    * @type bool
    */
    kHardLimitRevEn = 53;

    /*
    * Soft limit enable, disabled by default
    * @default 0
    * @type bool
    */
    kSoftLimitFwdEn = 54;

    /*
    * Soft limit enable, disabled by default
    * @default 0
    * @type bool
    */
    kSoftLimitRevEn = 55;

    /*
    * Voltage ramp rate active for all control modes in V/s, a value of 0 disable
    * s this feature
    * @default 0
    * @type float32
    * @unit V/s
    */
    kRampRate = 56;
}

/*
* Motor type enum, these values match the SPARK firmware
*/
enum motorType {
    Brushed = 0;
    Brushless = 1;
}

/*
* Sensor type enum, these values match the SPARK firmware
*/
enum sensorType {
    HallSensor = 0;
    Encoder = 1;
    Sensorless = 2;
}

/*
* Control type enum, these values match the SPARK firmware
*/
enum ctrlType {
    DutyCycle = 0;
    Velocity = 1;
}

/*
* Idle mode type enum, these values match the SPARK firmware
*/
enum idleMode {
    Coast = 0;
    Brake = 1;
}

/*
* Faults type enum, these values match the SPARK firmware
*/
enum faults {
    Brownout = 0;
    Overcurrent = 1;
    Overvoltage = 2;
    MotorFault = 3;
    SensorFault = 4;
    Stall = 5;
    EEPROMCRC = 6;
}

/*
* Sticky type enum, these values match the SPARK firmware
*/
enum stickyFaults {
    BrownoutSticky = 0;
    OvercurrentSticky = 1;
    OvervoltageSticky = 2;
    MotorFaultSticky = 3;
    SensorFaultSticky = 4;
    StallSticky = 5;
    EEPROMCRCSticky = 6;
}

/*
* Parameter type enum, these values match the SPARK firmware
* and are sent as a response in GetParameter() requests
*/
enum paramType {
    int32 = 0;
    uint32 = 1;
    float32 = 2;
    bool = 3;
}

/*
* Request type for Set/Get Parameter()
* value is not set to signify a 'Get' command
*/
message parameterRequest { 
    rootCommand root = 1;
    configParam parameter = 2;
    string value = 3;
}

/*
* Response type for Set/Get Parameter()
*/
message parameterResponse {
    string value = 1;
    paramType type = 2;
    rootResponse root = 4;
}

message parameterListRequest { 
    rootCommand root = 1;  
}

message parameterListResponse {
    repeated string parameter = 1;
    repeated paramType type = 2;
    rootResponse root = 3;
}

/*
* Request format for Setpoint() command
*/
message setpointRequest {
    rootCommand root = 1;  
    float setpoint = 2;
    bool enable = 3;
}

/*
* Response format for Setpoint() command
* isRunning is not implemented yet
*/
message setpointResponse {
    float setpoint = 1;
    bool isRunning = 2;
    rootResponse root = 3;
}

message followerRequest {
    rootCommand root = 1;
    uint32 followerid = 2;
    uint32 followerconfig = 3;
}
