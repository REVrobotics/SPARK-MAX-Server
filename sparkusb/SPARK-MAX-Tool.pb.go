// Code generated by protoc-gen-go. DO NOT EDIT.
// source: SPARK-MAX-Tool.proto

/*
Package sparkmax is a generated protocol buffer package.

It is generated from these files:
	SPARK-MAX-Tool.proto

It has these top-level messages:
	RequestWire
	ResponseWire
*/
package sparkmax

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import sparkmax2 "."

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

//
// Data format to send over 0mq containing one request
type RequestWire struct {
	// Types that are valid to be assigned to Req:
	//	*RequestWire_Root
	//	*RequestWire_CmdLine
	//	*RequestWire_List
	//	*RequestWire_Firmware
	//	*RequestWire_Heartbeat
	//	*RequestWire_Address
	//	*RequestWire_Parameter
	//	*RequestWire_ParameterList
	//	*RequestWire_Setpoint
	//	*RequestWire_Control
	//	*RequestWire_Follower
	//	*RequestWire_Burn
	Req isRequestWire_Req `protobuf_oneof:"req"`
}

func (m *RequestWire) Reset()                    { *m = RequestWire{} }
func (m *RequestWire) String() string            { return proto.CompactTextString(m) }
func (*RequestWire) ProtoMessage()               {}
func (*RequestWire) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isRequestWire_Req interface{ isRequestWire_Req() }

type RequestWire_Root struct {
	Root *sparkmax2.RootCommand `protobuf:"bytes,10,opt,name=root,oneof"`
}
type RequestWire_CmdLine struct {
	CmdLine *sparkmax2.CommandLineRequest `protobuf:"bytes,11,opt,name=cmdLine,oneof"`
}
type RequestWire_List struct {
	List *sparkmax2.ListRequest `protobuf:"bytes,12,opt,name=list,oneof"`
}
type RequestWire_Firmware struct {
	Firmware *sparkmax2.FirmwareRequest `protobuf:"bytes,13,opt,name=firmware,oneof"`
}
type RequestWire_Heartbeat struct {
	Heartbeat *sparkmax2.HeartbeatRequest `protobuf:"bytes,14,opt,name=heartbeat,oneof"`
}
type RequestWire_Address struct {
	Address *sparkmax2.AddressRequest `protobuf:"bytes,15,opt,name=address,oneof"`
}
type RequestWire_Parameter struct {
	Parameter *sparkmax2.ParameterRequest `protobuf:"bytes,16,opt,name=parameter,oneof"`
}
type RequestWire_ParameterList struct {
	ParameterList *sparkmax2.ParameterListRequest `protobuf:"bytes,17,opt,name=parameterList,oneof"`
}
type RequestWire_Setpoint struct {
	Setpoint *sparkmax2.SetpointRequest `protobuf:"bytes,18,opt,name=setpoint,oneof"`
}
type RequestWire_Control struct {
	Control *sparkmax2.ControlRequest `protobuf:"bytes,19,opt,name=control,oneof"`
}
type RequestWire_Follower struct {
	Follower *sparkmax2.FollowerRequest `protobuf:"bytes,20,opt,name=follower,oneof"`
}
type RequestWire_Burn struct {
	Burn *sparkmax2.BurnRequest `protobuf:"bytes,21,opt,name=burn,oneof"`
}

func (*RequestWire_Root) isRequestWire_Req()          {}
func (*RequestWire_CmdLine) isRequestWire_Req()       {}
func (*RequestWire_List) isRequestWire_Req()          {}
func (*RequestWire_Firmware) isRequestWire_Req()      {}
func (*RequestWire_Heartbeat) isRequestWire_Req()     {}
func (*RequestWire_Address) isRequestWire_Req()       {}
func (*RequestWire_Parameter) isRequestWire_Req()     {}
func (*RequestWire_ParameterList) isRequestWire_Req() {}
func (*RequestWire_Setpoint) isRequestWire_Req()      {}
func (*RequestWire_Control) isRequestWire_Req()       {}
func (*RequestWire_Follower) isRequestWire_Req()      {}
func (*RequestWire_Burn) isRequestWire_Req()          {}

func (m *RequestWire) GetReq() isRequestWire_Req {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *RequestWire) GetRoot() *sparkmax2.RootCommand {
	if x, ok := m.GetReq().(*RequestWire_Root); ok {
		return x.Root
	}
	return nil
}

func (m *RequestWire) GetCmdLine() *sparkmax2.CommandLineRequest {
	if x, ok := m.GetReq().(*RequestWire_CmdLine); ok {
		return x.CmdLine
	}
	return nil
}

func (m *RequestWire) GetList() *sparkmax2.ListRequest {
	if x, ok := m.GetReq().(*RequestWire_List); ok {
		return x.List
	}
	return nil
}

func (m *RequestWire) GetFirmware() *sparkmax2.FirmwareRequest {
	if x, ok := m.GetReq().(*RequestWire_Firmware); ok {
		return x.Firmware
	}
	return nil
}

func (m *RequestWire) GetHeartbeat() *sparkmax2.HeartbeatRequest {
	if x, ok := m.GetReq().(*RequestWire_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

func (m *RequestWire) GetAddress() *sparkmax2.AddressRequest {
	if x, ok := m.GetReq().(*RequestWire_Address); ok {
		return x.Address
	}
	return nil
}

func (m *RequestWire) GetParameter() *sparkmax2.ParameterRequest {
	if x, ok := m.GetReq().(*RequestWire_Parameter); ok {
		return x.Parameter
	}
	return nil
}

func (m *RequestWire) GetParameterList() *sparkmax2.ParameterListRequest {
	if x, ok := m.GetReq().(*RequestWire_ParameterList); ok {
		return x.ParameterList
	}
	return nil
}

func (m *RequestWire) GetSetpoint() *sparkmax2.SetpointRequest {
	if x, ok := m.GetReq().(*RequestWire_Setpoint); ok {
		return x.Setpoint
	}
	return nil
}

func (m *RequestWire) GetControl() *sparkmax2.ControlRequest {
	if x, ok := m.GetReq().(*RequestWire_Control); ok {
		return x.Control
	}
	return nil
}

func (m *RequestWire) GetFollower() *sparkmax2.FollowerRequest {
	if x, ok := m.GetReq().(*RequestWire_Follower); ok {
		return x.Follower
	}
	return nil
}

func (m *RequestWire) GetBurn() *sparkmax2.BurnRequest {
	if x, ok := m.GetReq().(*RequestWire_Burn); ok {
		return x.Burn
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RequestWire) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RequestWire_OneofMarshaler, _RequestWire_OneofUnmarshaler, _RequestWire_OneofSizer, []interface{}{
		(*RequestWire_Root)(nil),
		(*RequestWire_CmdLine)(nil),
		(*RequestWire_List)(nil),
		(*RequestWire_Firmware)(nil),
		(*RequestWire_Heartbeat)(nil),
		(*RequestWire_Address)(nil),
		(*RequestWire_Parameter)(nil),
		(*RequestWire_ParameterList)(nil),
		(*RequestWire_Setpoint)(nil),
		(*RequestWire_Control)(nil),
		(*RequestWire_Follower)(nil),
		(*RequestWire_Burn)(nil),
	}
}

func _RequestWire_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RequestWire)
	// req
	switch x := m.Req.(type) {
	case *RequestWire_Root:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Root); err != nil {
			return err
		}
	case *RequestWire_CmdLine:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CmdLine); err != nil {
			return err
		}
	case *RequestWire_List:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.List); err != nil {
			return err
		}
	case *RequestWire_Firmware:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Firmware); err != nil {
			return err
		}
	case *RequestWire_Heartbeat:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Heartbeat); err != nil {
			return err
		}
	case *RequestWire_Address:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Address); err != nil {
			return err
		}
	case *RequestWire_Parameter:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Parameter); err != nil {
			return err
		}
	case *RequestWire_ParameterList:
		b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ParameterList); err != nil {
			return err
		}
	case *RequestWire_Setpoint:
		b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Setpoint); err != nil {
			return err
		}
	case *RequestWire_Control:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Control); err != nil {
			return err
		}
	case *RequestWire_Follower:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Follower); err != nil {
			return err
		}
	case *RequestWire_Burn:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Burn); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RequestWire.Req has unexpected type %T", x)
	}
	return nil
}

func _RequestWire_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RequestWire)
	switch tag {
	case 10: // req.root
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.RootCommand)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_Root{msg}
		return true, err
	case 11: // req.cmdLine
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.CommandLineRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_CmdLine{msg}
		return true, err
	case 12: // req.list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.ListRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_List{msg}
		return true, err
	case 13: // req.firmware
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.FirmwareRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_Firmware{msg}
		return true, err
	case 14: // req.heartbeat
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.HeartbeatRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_Heartbeat{msg}
		return true, err
	case 15: // req.address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.AddressRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_Address{msg}
		return true, err
	case 16: // req.parameter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.ParameterRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_Parameter{msg}
		return true, err
	case 17: // req.parameterList
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.ParameterListRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_ParameterList{msg}
		return true, err
	case 18: // req.setpoint
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.SetpointRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_Setpoint{msg}
		return true, err
	case 19: // req.control
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.ControlRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_Control{msg}
		return true, err
	case 20: // req.follower
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.FollowerRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_Follower{msg}
		return true, err
	case 21: // req.burn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.BurnRequest)
		err := b.DecodeMessage(msg)
		m.Req = &RequestWire_Burn{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RequestWire_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RequestWire)
	// req
	switch x := m.Req.(type) {
	case *RequestWire_Root:
		s := proto.Size(x.Root)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_CmdLine:
		s := proto.Size(x.CmdLine)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_List:
		s := proto.Size(x.List)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_Firmware:
		s := proto.Size(x.Firmware)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_Heartbeat:
		s := proto.Size(x.Heartbeat)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_Address:
		s := proto.Size(x.Address)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_Parameter:
		s := proto.Size(x.Parameter)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_ParameterList:
		s := proto.Size(x.ParameterList)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_Setpoint:
		s := proto.Size(x.Setpoint)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_Control:
		s := proto.Size(x.Control)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_Follower:
		s := proto.Size(x.Follower)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RequestWire_Burn:
		s := proto.Size(x.Burn)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

//
// Data format to recieve over 0mq containting one response
type ResponseWire struct {
	// Types that are valid to be assigned to Resp:
	//	*ResponseWire_Root
	//	*ResponseWire_CmdLine
	//	*ResponseWire_List
	//	*ResponseWire_Firmware
	//	*ResponseWire_Address
	//	*ResponseWire_Parameter
	//	*ResponseWire_Parameterlist
	//	*ResponseWire_Setpoint
	//	*ResponseWire_Control
	//	*ResponseWire_Burn
	Resp isResponseWire_Resp `protobuf_oneof:"resp"`
}

func (m *ResponseWire) Reset()                    { *m = ResponseWire{} }
func (m *ResponseWire) String() string            { return proto.CompactTextString(m) }
func (*ResponseWire) ProtoMessage()               {}
func (*ResponseWire) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isResponseWire_Resp interface{ isResponseWire_Resp() }

type ResponseWire_Root struct {
	Root *sparkmax2.RootResponse `protobuf:"bytes,10,opt,name=root,oneof"`
}
type ResponseWire_CmdLine struct {
	CmdLine *sparkmax2.CommandLineResponse `protobuf:"bytes,11,opt,name=cmdLine,oneof"`
}
type ResponseWire_List struct {
	List *sparkmax2.ListResponse `protobuf:"bytes,12,opt,name=list,oneof"`
}
type ResponseWire_Firmware struct {
	Firmware *sparkmax2.FirmwareResponse `protobuf:"bytes,13,opt,name=firmware,oneof"`
}
type ResponseWire_Address struct {
	Address *sparkmax2.AddressResponse `protobuf:"bytes,14,opt,name=address,oneof"`
}
type ResponseWire_Parameter struct {
	Parameter *sparkmax2.ParameterResponse `protobuf:"bytes,15,opt,name=parameter,oneof"`
}
type ResponseWire_Parameterlist struct {
	Parameterlist *sparkmax2.ParameterListResponse `protobuf:"bytes,16,opt,name=parameterlist,oneof"`
}
type ResponseWire_Setpoint struct {
	Setpoint *sparkmax2.SetpointResponse `protobuf:"bytes,17,opt,name=setpoint,oneof"`
}
type ResponseWire_Control struct {
	Control *sparkmax2.ControlResponse `protobuf:"bytes,18,opt,name=control,oneof"`
}
type ResponseWire_Burn struct {
	Burn *sparkmax2.BurnResponse `protobuf:"bytes,19,opt,name=burn,oneof"`
}

func (*ResponseWire_Root) isResponseWire_Resp()          {}
func (*ResponseWire_CmdLine) isResponseWire_Resp()       {}
func (*ResponseWire_List) isResponseWire_Resp()          {}
func (*ResponseWire_Firmware) isResponseWire_Resp()      {}
func (*ResponseWire_Address) isResponseWire_Resp()       {}
func (*ResponseWire_Parameter) isResponseWire_Resp()     {}
func (*ResponseWire_Parameterlist) isResponseWire_Resp() {}
func (*ResponseWire_Setpoint) isResponseWire_Resp()      {}
func (*ResponseWire_Control) isResponseWire_Resp()       {}
func (*ResponseWire_Burn) isResponseWire_Resp()          {}

func (m *ResponseWire) GetResp() isResponseWire_Resp {
	if m != nil {
		return m.Resp
	}
	return nil
}

func (m *ResponseWire) GetRoot() *sparkmax2.RootResponse {
	if x, ok := m.GetResp().(*ResponseWire_Root); ok {
		return x.Root
	}
	return nil
}

func (m *ResponseWire) GetCmdLine() *sparkmax2.CommandLineResponse {
	if x, ok := m.GetResp().(*ResponseWire_CmdLine); ok {
		return x.CmdLine
	}
	return nil
}

func (m *ResponseWire) GetList() *sparkmax2.ListResponse {
	if x, ok := m.GetResp().(*ResponseWire_List); ok {
		return x.List
	}
	return nil
}

func (m *ResponseWire) GetFirmware() *sparkmax2.FirmwareResponse {
	if x, ok := m.GetResp().(*ResponseWire_Firmware); ok {
		return x.Firmware
	}
	return nil
}

func (m *ResponseWire) GetAddress() *sparkmax2.AddressResponse {
	if x, ok := m.GetResp().(*ResponseWire_Address); ok {
		return x.Address
	}
	return nil
}

func (m *ResponseWire) GetParameter() *sparkmax2.ParameterResponse {
	if x, ok := m.GetResp().(*ResponseWire_Parameter); ok {
		return x.Parameter
	}
	return nil
}

func (m *ResponseWire) GetParameterlist() *sparkmax2.ParameterListResponse {
	if x, ok := m.GetResp().(*ResponseWire_Parameterlist); ok {
		return x.Parameterlist
	}
	return nil
}

func (m *ResponseWire) GetSetpoint() *sparkmax2.SetpointResponse {
	if x, ok := m.GetResp().(*ResponseWire_Setpoint); ok {
		return x.Setpoint
	}
	return nil
}

func (m *ResponseWire) GetControl() *sparkmax2.ControlResponse {
	if x, ok := m.GetResp().(*ResponseWire_Control); ok {
		return x.Control
	}
	return nil
}

func (m *ResponseWire) GetBurn() *sparkmax2.BurnResponse {
	if x, ok := m.GetResp().(*ResponseWire_Burn); ok {
		return x.Burn
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ResponseWire) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ResponseWire_OneofMarshaler, _ResponseWire_OneofUnmarshaler, _ResponseWire_OneofSizer, []interface{}{
		(*ResponseWire_Root)(nil),
		(*ResponseWire_CmdLine)(nil),
		(*ResponseWire_List)(nil),
		(*ResponseWire_Firmware)(nil),
		(*ResponseWire_Address)(nil),
		(*ResponseWire_Parameter)(nil),
		(*ResponseWire_Parameterlist)(nil),
		(*ResponseWire_Setpoint)(nil),
		(*ResponseWire_Control)(nil),
		(*ResponseWire_Burn)(nil),
	}
}

func _ResponseWire_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ResponseWire)
	// resp
	switch x := m.Resp.(type) {
	case *ResponseWire_Root:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Root); err != nil {
			return err
		}
	case *ResponseWire_CmdLine:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CmdLine); err != nil {
			return err
		}
	case *ResponseWire_List:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.List); err != nil {
			return err
		}
	case *ResponseWire_Firmware:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Firmware); err != nil {
			return err
		}
	case *ResponseWire_Address:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Address); err != nil {
			return err
		}
	case *ResponseWire_Parameter:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Parameter); err != nil {
			return err
		}
	case *ResponseWire_Parameterlist:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Parameterlist); err != nil {
			return err
		}
	case *ResponseWire_Setpoint:
		b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Setpoint); err != nil {
			return err
		}
	case *ResponseWire_Control:
		b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Control); err != nil {
			return err
		}
	case *ResponseWire_Burn:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Burn); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ResponseWire.Resp has unexpected type %T", x)
	}
	return nil
}

func _ResponseWire_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ResponseWire)
	switch tag {
	case 10: // resp.root
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.RootResponse)
		err := b.DecodeMessage(msg)
		m.Resp = &ResponseWire_Root{msg}
		return true, err
	case 11: // resp.cmdLine
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.CommandLineResponse)
		err := b.DecodeMessage(msg)
		m.Resp = &ResponseWire_CmdLine{msg}
		return true, err
	case 12: // resp.list
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.ListResponse)
		err := b.DecodeMessage(msg)
		m.Resp = &ResponseWire_List{msg}
		return true, err
	case 13: // resp.firmware
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.FirmwareResponse)
		err := b.DecodeMessage(msg)
		m.Resp = &ResponseWire_Firmware{msg}
		return true, err
	case 14: // resp.address
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.AddressResponse)
		err := b.DecodeMessage(msg)
		m.Resp = &ResponseWire_Address{msg}
		return true, err
	case 15: // resp.parameter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.ParameterResponse)
		err := b.DecodeMessage(msg)
		m.Resp = &ResponseWire_Parameter{msg}
		return true, err
	case 16: // resp.parameterlist
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.ParameterListResponse)
		err := b.DecodeMessage(msg)
		m.Resp = &ResponseWire_Parameterlist{msg}
		return true, err
	case 17: // resp.setpoint
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.SetpointResponse)
		err := b.DecodeMessage(msg)
		m.Resp = &ResponseWire_Setpoint{msg}
		return true, err
	case 18: // resp.control
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.ControlResponse)
		err := b.DecodeMessage(msg)
		m.Resp = &ResponseWire_Control{msg}
		return true, err
	case 19: // resp.burn
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(sparkmax2.BurnResponse)
		err := b.DecodeMessage(msg)
		m.Resp = &ResponseWire_Burn{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ResponseWire_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ResponseWire)
	// resp
	switch x := m.Resp.(type) {
	case *ResponseWire_Root:
		s := proto.Size(x.Root)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseWire_CmdLine:
		s := proto.Size(x.CmdLine)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseWire_List:
		s := proto.Size(x.List)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseWire_Firmware:
		s := proto.Size(x.Firmware)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseWire_Address:
		s := proto.Size(x.Address)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseWire_Parameter:
		s := proto.Size(x.Parameter)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseWire_Parameterlist:
		s := proto.Size(x.Parameterlist)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseWire_Setpoint:
		s := proto.Size(x.Setpoint)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseWire_Control:
		s := proto.Size(x.Control)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ResponseWire_Burn:
		s := proto.Size(x.Burn)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*RequestWire)(nil), "sparkmax.RequestWire")
	proto.RegisterType((*ResponseWire)(nil), "sparkmax.ResponseWire")
}

func init() { proto.RegisterFile("SPARK-MAX-Tool.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 627 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x95, 0xdb, 0x6e, 0xd3, 0x4c,
	0x10, 0xc7, 0xf3, 0xe9, 0xcb, 0x71, 0x92, 0x16, 0xba, 0x3d, 0x68, 0x31, 0x47, 0xe5, 0x0a, 0x89,
	0x34, 0x17, 0x85, 0xaa, 0xe5, 0x24, 0x91, 0x06, 0xa5, 0x41, 0x04, 0x29, 0x4a, 0x90, 0xe0, 0xd6,
	0x49, 0x16, 0x6a, 0x61, 0x7b, 0xdd, 0xdd, 0x8d, 0xca, 0x03, 0x71, 0xc9, 0x5b, 0xf0, 0x62, 0x68,
	0xd7, 0xf6, 0xae, 0xed, 0x78, 0x73, 0x01, 0x5c, 0x7a, 0x66, 0xfe, 0x33, 0x9e, 0x99, 0x9f, 0xc7,
	0x70, 0x30, 0x9f, 0x0e, 0x66, 0xef, 0x8f, 0x3f, 0x0c, 0x3e, 0x1f, 0x7f, 0xa4, 0xd4, 0xef, 0x47,
	0x8c, 0x0a, 0x8a, 0x9a, 0x3c, 0x72, 0xd9, 0xb7, 0xc0, 0xfd, 0xee, 0x60, 0xe3, 0x1f, 0xd2, 0x20,
	0x70, 0xc3, 0x15, 0x8f, 0x63, 0xba, 0x3f, 0x6b, 0xd0, 0x9e, 0x91, 0xeb, 0x35, 0xe1, 0xe2, 0x93,
	0xc7, 0x08, 0x7a, 0x02, 0x55, 0x46, 0xa9, 0xc0, 0xf0, 0xe8, 0xbf, 0xc7, 0xed, 0x93, 0xc3, 0x7e,
	0x9a, 0xa2, 0x2f, 0xad, 0x89, 0x76, 0x5c, 0x99, 0xa9, 0x20, 0x74, 0x0e, 0x8d, 0x65, 0xb0, 0x9a,
	0x78, 0x21, 0xc1, 0x6d, 0x15, 0x7f, 0xcf, 0xc4, 0x2f, 0xe3, 0x58, 0xe9, 0x4c, 0xf2, 0x8f, 0x2b,
	0xb3, 0x34, 0x5c, 0x96, 0xf1, 0x3d, 0x2e, 0x70, 0xa7, 0x58, 0x46, 0x5a, 0x4d, 0xbc, 0x0a, 0x42,
	0x67, 0xd0, 0xfc, 0xe2, 0xb1, 0xe0, 0xc6, 0x65, 0x04, 0xef, 0x28, 0xc1, 0x1d, 0x23, 0x48, 0x3d,
	0x46, 0xa4, 0x83, 0xd1, 0x0b, 0x68, 0x5d, 0x11, 0x97, 0x89, 0x05, 0x71, 0x05, 0xde, 0x55, 0x4a,
	0xc7, 0x28, 0xb5, 0xcb, 0x48, 0x4d, 0x38, 0x7a, 0x06, 0x0d, 0x77, 0xb5, 0x62, 0x84, 0x73, 0x7c,
	0x4b, 0x29, 0xb1, 0x51, 0x26, 0x8e, 0x4c, 0x5f, 0x89, 0x45, 0x56, 0x8c, 0x5c, 0xe6, 0x06, 0x44,
	0x10, 0x86, 0x6f, 0x17, 0x2b, 0x6a, 0x57, 0xa6, 0xa2, 0xb6, 0xa1, 0x11, 0xec, 0xe8, 0x87, 0x89,
	0x1c, 0xce, 0x9e, 0xd2, 0x3f, 0x28, 0xd1, 0x4f, 0x72, 0x53, 0xca, 0xcb, 0xe4, 0xb8, 0x38, 0x11,
	0x11, 0xf5, 0x42, 0x81, 0x51, 0x71, 0x5c, 0xa9, 0x27, 0x33, 0xae, 0xd4, 0x24, 0x5b, 0x5e, 0xd2,
	0x50, 0x30, 0xea, 0xe3, 0xfd, 0x62, 0xcb, 0x89, 0x23, 0xbb, 0xca, 0xd8, 0xa2, 0xb6, 0x43, 0x7d,
	0x9f, 0xde, 0x10, 0x86, 0x0f, 0x36, 0xb6, 0x93, 0x78, 0xb2, 0xdb, 0x49, 0x4c, 0x92, 0x81, 0xc5,
	0x9a, 0x85, 0xf8, 0xb0, 0xc8, 0x80, 0xb4, 0x66, 0x18, 0x90, 0x8f, 0x17, 0x35, 0xf8, 0x9f, 0x91,
	0xeb, 0xee, 0xaf, 0x2a, 0x74, 0x66, 0x84, 0x47, 0x34, 0xe4, 0x44, 0xf1, 0xda, 0xcb, 0xf1, 0x7a,
	0x94, 0xe7, 0x35, 0x8d, 0xd4, 0xc0, 0x3e, 0x2f, 0x02, 0x7b, 0xdf, 0x02, 0xac, 0xd6, 0x69, 0x62,
	0x7b, 0x39, 0x62, 0x8f, 0x8a, 0xc4, 0x9a, 0x42, 0x0a, 0xd9, 0xf3, 0x0d, 0x64, 0x9d, 0x32, 0x64,
	0xb5, 0xca, 0x30, 0x7b, 0x6a, 0xb8, 0xdb, 0x2d, 0x4e, 0x53, 0x73, 0x67, 0x5e, 0x2f, 0x05, 0xef,
	0x65, 0x16, 0xbc, 0x18, 0xd8, 0xbb, 0xa5, 0xe0, 0x69, 0x69, 0x86, 0xbc, 0xcb, 0x0c, 0x79, 0xaa,
	0xc9, 0x98, 0xdc, 0x87, 0x56, 0xf2, 0x74, 0x92, 0xbc, 0x4e, 0xb6, 0xad, 0xd1, 0xdb, 0x2b, 0xb6,
	0x6d, 0xd0, 0x33, 0x6d, 0x6b, 0xf6, 0x4e, 0x0d, 0x7b, 0x1b, 0xcc, 0x6a, 0xf6, 0x32, 0x5b, 0x49,
	0xe0, 0xeb, 0x25, 0x0c, 0xed, 0x17, 0xb7, 0x12, 0x33, 0x64, 0xb6, 0xa2, 0x20, 0xaa, 0x43, 0x95,
	0x11, 0x1e, 0x9d, 0xfc, 0xa8, 0x41, 0x7c, 0x1b, 0xd7, 0x7c, 0x81, 0xde, 0x40, 0x63, 0x48, 0xc3,
	0x90, 0x2c, 0x05, 0xb2, 0xf2, 0xee, 0xd8, 0xdf, 0xa6, 0x5b, 0x41, 0x43, 0x80, 0xb7, 0x1e, 0x5f,
	0xfe, 0x5d, 0x92, 0xd7, 0x50, 0x9d, 0x7a, 0xe1, 0xd7, 0x3f, 0x95, 0x9f, 0x41, 0x55, 0x7d, 0xfc,
	0xe5, 0xa7, 0xd4, 0xb1, 0xf0, 0xda, 0xad, 0xa0, 0x01, 0xb4, 0xc6, 0xfa, 0xe8, 0x6d, 0xb9, 0x8e,
	0x8e, 0xe5, 0xdb, 0xea, 0x56, 0xd0, 0x3b, 0xe8, 0xcc, 0x89, 0x98, 0x6a, 0x9c, 0xb6, 0x5c, 0x3c,
	0x67, 0x1b, 0x94, 0x71, 0xaa, 0xcb, 0x7f, 0x94, 0xea, 0x15, 0xb4, 0x2e, 0xd6, 0x2c, 0x1c, 0xf9,
	0x2e, 0xbf, 0x42, 0xe5, 0xd7, 0xc5, 0xb1, 0x00, 0xa3, 0x76, 0xda, 0x9c, 0xa7, 0x6c, 0xda, 0xcf,
	0xa7, 0xb3, 0x05, 0x6f, 0xb5, 0xd3, 0xfa, 0x48, 0x5d, 0x3b, 0x64, 0x3f, 0x89, 0xf6, 0xb9, 0x2e,
	0xea, 0xea, 0x17, 0xfd, 0xf4, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0xad, 0xcf, 0x72, 0xde,
	0x07, 0x00, 0x00,
}
