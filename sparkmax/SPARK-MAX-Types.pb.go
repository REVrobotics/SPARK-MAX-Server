// Code generated by protoc-gen-go. DO NOT EDIT.
// source: SPARK-MAX-Types.proto

package sparkmax

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
// Motor type enum, these values match the SPARK firmware
type MotorType int32

const (
	MotorType_Brushed   MotorType = 0
	MotorType_Brushless MotorType = 1
)

var MotorType_name = map[int32]string{
	0: "Brushed",
	1: "Brushless",
}
var MotorType_value = map[string]int32{
	"Brushed":   0,
	"Brushless": 1,
}

func (x MotorType) String() string {
	return proto.EnumName(MotorType_name, int32(x))
}
func (MotorType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

//
// Sensor type enum, these values match the SPARK firmware
type SensorType int32

const (
	SensorType_NoSensor   SensorType = 0
	SensorType_HallSensor SensorType = 1
	SensorType_Encoder    SensorType = 2
	SensorType_Sensorless SensorType = 3
)

var SensorType_name = map[int32]string{
	0: "NoSensor",
	1: "HallSensor",
	2: "Encoder",
	3: "Sensorless",
}
var SensorType_value = map[string]int32{
	"NoSensor":   0,
	"HallSensor": 1,
	"Encoder":    2,
	"Sensorless": 3,
}

func (x SensorType) String() string {
	return proto.EnumName(SensorType_name, int32(x))
}
func (SensorType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

//
// Control type enum, these values match the SPARK firmware
type CtrlType int32

const (
	CtrlType_DutyCycle CtrlType = 0
	CtrlType_Velocity  CtrlType = 1
	CtrlType_Voltage   CtrlType = 2
)

var CtrlType_name = map[int32]string{
	0: "DutyCycle",
	1: "Velocity",
	2: "Voltage",
}
var CtrlType_value = map[string]int32{
	"DutyCycle": 0,
	"Velocity":  1,
	"Voltage":   2,
}

func (x CtrlType) String() string {
	return proto.EnumName(CtrlType_name, int32(x))
}
func (CtrlType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

//
// Idle mode type enum, these values match the SPARK firmware
type IdleMode int32

const (
	IdleMode_Coast IdleMode = 0
	IdleMode_Brake IdleMode = 1
)

var IdleMode_name = map[int32]string{
	0: "Coast",
	1: "Brake",
}
var IdleMode_value = map[string]int32{
	"Coast": 0,
	"Brake": 1,
}

func (x IdleMode) String() string {
	return proto.EnumName(IdleMode_name, int32(x))
}
func (IdleMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

//
// Input mode type enum, these values match the SPARK firmware
type InputMode int32

const (
	InputMode_PWM InputMode = 0
	InputMode_CAN InputMode = 1
)

var InputMode_name = map[int32]string{
	0: "PWM",
	1: "CAN",
}
var InputMode_value = map[string]int32{
	"PWM": 0,
	"CAN": 1,
}

func (x InputMode) String() string {
	return proto.EnumName(InputMode_name, int32(x))
}
func (InputMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

//
// Faults type enum, these valInvalidIDues match the SPARK firmware
type Faults int32

const (
	Faults_Brownout     Faults = 0
	Faults_Overcurrent  Faults = 1
	Faults_Overvoltage  Faults = 2
	Faults_MotorFault   Faults = 3
	Faults_SensorFault  Faults = 4
	Faults_Stall        Faults = 5
	Faults_EEPROMCRC    Faults = 6
	Faults_CANTX        Faults = 7
	Faults_CANRX        Faults = 8
	Faults_HasReset     Faults = 9
	Faults_DRVFault     Faults = 10
	Faults_SoftLimitFwd Faults = 12
	Faults_SoftLimitRev Faults = 13
	Faults_HardLimitFwd Faults = 14
	Faults_HardLimitRev Faults = 15
)

var Faults_name = map[int32]string{
	0:  "Brownout",
	1:  "Overcurrent",
	2:  "Overvoltage",
	3:  "MotorFault",
	4:  "SensorFault",
	5:  "Stall",
	6:  "EEPROMCRC",
	7:  "CANTX",
	8:  "CANRX",
	9:  "HasReset",
	10: "DRVFault",
	12: "SoftLimitFwd",
	13: "SoftLimitRev",
	14: "HardLimitFwd",
	15: "HardLimitRev",
}
var Faults_value = map[string]int32{
	"Brownout":     0,
	"Overcurrent":  1,
	"Overvoltage":  2,
	"MotorFault":   3,
	"SensorFault":  4,
	"Stall":        5,
	"EEPROMCRC":    6,
	"CANTX":        7,
	"CANRX":        8,
	"HasReset":     9,
	"DRVFault":     10,
	"SoftLimitFwd": 12,
	"SoftLimitRev": 13,
	"HardLimitFwd": 14,
	"HardLimitRev": 15,
}

func (x Faults) String() string {
	return proto.EnumName(Faults_name, int32(x))
}
func (Faults) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

//
// Parameter type enum, these values match the SPARK firmware
// and are sent as a response in GetParameter() requests
type ParamType int32

const (
	ParamType_int32   ParamType = 0
	ParamType_uint32  ParamType = 1
	ParamType_float32 ParamType = 2
	ParamType_bool    ParamType = 3
)

var ParamType_name = map[int32]string{
	0: "int32",
	1: "uint32",
	2: "float32",
	3: "bool",
}
var ParamType_value = map[string]int32{
	"int32":   0,
	"uint32":  1,
	"float32": 2,
	"bool":    3,
}

func (x ParamType) String() string {
	return proto.EnumName(ParamType_name, int32(x))
}
func (ParamType) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

//
// Parameter Status returned from get/set parameter
type ParamStatus int32

const (
	ParamStatus_paramOK                  ParamStatus = 0
	ParamStatus_InvalidID                ParamStatus = 1
	ParamStatus_MismatchType             ParamStatus = 2
	ParamStatus_AccessMode               ParamStatus = 3
	ParamStatus_Invalid                  ParamStatus = 4
	ParamStatus_NotImplementedDeprecated ParamStatus = 5
)

var ParamStatus_name = map[int32]string{
	0: "paramOK",
	1: "InvalidID",
	2: "MismatchType",
	3: "AccessMode",
	4: "Invalid",
	5: "NotImplementedDeprecated",
}
var ParamStatus_value = map[string]int32{
	"paramOK":                  0,
	"InvalidID":                1,
	"MismatchType":             2,
	"AccessMode":               3,
	"Invalid":                  4,
	"NotImplementedDeprecated": 5,
}

func (x ParamStatus) String() string {
	return proto.EnumName(ParamStatus_name, int32(x))
}
func (ParamStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

//
// Follower ID for pre-defined CAN protocols
type DefinedFollowerID int32

const (
	DefinedFollowerID_FollowerDisabled DefinedFollowerID = 0
	DefinedFollowerID_FollowerCustom   DefinedFollowerID = 25
	DefinedFollowerID_FollowerSparkMax DefinedFollowerID = 26
	DefinedFollowerID_FollowerPhoenix  DefinedFollowerID = 27
)

var DefinedFollowerID_name = map[int32]string{
	0:  "FollowerDisabled",
	25: "FollowerCustom",
	26: "FollowerSparkMax",
	27: "FollowerPhoenix",
}
var DefinedFollowerID_value = map[string]int32{
	"FollowerDisabled": 0,
	"FollowerCustom":   25,
	"FollowerSparkMax": 26,
	"FollowerPhoenix":  27,
}

func (x DefinedFollowerID) String() string {
	return proto.EnumName(DefinedFollowerID_name, int32(x))
}
func (DefinedFollowerID) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

//
// Follower sign mode
type FollowerSignMode int32

const (
	FollowerSignMode_FollowerNoSign   FollowerSignMode = 0
	FollowerSignMode_FollowerTwosComp FollowerSignMode = 1
	FollowerSignMode_FollowerSignMag  FollowerSignMode = 2
)

var FollowerSignMode_name = map[int32]string{
	0: "FollowerNoSign",
	1: "FollowerTwosComp",
	2: "FollowerSignMag",
}
var FollowerSignMode_value = map[string]int32{
	"FollowerNoSign":   0,
	"FollowerTwosComp": 1,
	"FollowerSignMag":  2,
}

func (x FollowerSignMode) String() string {
	return proto.EnumName(FollowerSignMode_name, int32(x))
}
func (FollowerSignMode) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

//
// Parameter ID for set/get parameter fields
// these values match the SPARK firmware
// @omit THIS ENUM IS AUTO GENERATED FROM SPREADSHEET
type ConfigParam int32

const (
	//
	// CAN ID
	// @default 0
	// @type uint
	ConfigParam_kCanID ConfigParam = 0
	//
	// Input mode, this parameter is read only and the input mode is detected by t
	// he firmware automatically, results are %Input Mode%
	// @default 0
	// @type Input Mode
	ConfigParam_kInputMode ConfigParam = 1
	//
	// Motor Type, options are %Motor Type%
	// @default BRUSHED
	// @type Motor Type
	ConfigParam_kMotorType ConfigParam = 2
	//
	// Electrical degree of offset from the backemf crossing to commutation for se
	// nsorless modes. This is currently not implemented
	// @default 0
	// @type float32
	// @unit Degrees
	ConfigParam_kCommAdvance ConfigParam = 3
	//
	// Sensor Type, options are %Sensor Type%
	// @default HALL_SENSOR
	// @type Sensor Type
	ConfigParam_kSensorType ConfigParam = 4
	//
	// Control Type, this is a read only parameter of the currently active control
	//  type. Options are %Ctrl Type%
	// @default CTRL_DUTY_CYCLE
	// @type Ctrl Type
	ConfigParam_kCtrlType ConfigParam = 5
	//
	// State of the half bridge when the motor controller commands zero output or
	// is disabled. Options are %Idle Mode%
	// @default IDLE_COAST
	// @type Idle Mode
	ConfigParam_kIdleMode ConfigParam = 6
	//
	// Percent of the input which results in zero output
	// @default 0.05
	// @type float32
	// @unit Percent
	ConfigParam_kInputDeadband ConfigParam = 7
	//
	// Read only parameter showing the 32-bit firmware version. The first byte is
	// the major build, the second byte is in the minor build, the last two bytes
	//  are the build
	// @default 0
	// @type Firmware
	ConfigParam_kFirmwareVer ConfigParam = 8
	//
	// Electrical offset of the hall sensor compared to the motor phases in degree
	// s. Typically this is either 0, 60, 120
	// @default 0
	// @type int
	// @unit Degrees
	ConfigParam_kHallOffset ConfigParam = 9
	//
	// Number of pole pairs for the brushless motor. This is the number of poles/2
	//  and can be determined by either counting the number of magents or countin
	// g the number of windings and dividing by 3. This is an important term for
	// speed regulation to properly calculate the speed
	// @default 1
	// @type uint
	ConfigParam_kPolePairs ConfigParam = 10
	//
	// If the half bridge detects this current limit, it will disable the motor dr
	// iver until the current goes below a certain threshold before enabling. Thi
	// s is a low sophistication 'current control'
	// @default 0
	// @type float32
	// @unit Amps
	ConfigParam_kCurrentChop ConfigParam = 11
	//
	// If the half bridge detects this current limit, it will disable the motor dr
	// iver and report a sticky fault. The motor driver will not enable again unt
	// il this fault is cleared.
	// @default 0
	// @type float32
	// @unit Amps
	ConfigParam_kCurrentLimit ConfigParam = 12
	//
	// Perportional gain constant for gain slot 0. In cascaded control modes this
	// is the inner loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kP_0 ConfigParam = 13
	//
	// Integral gain constant for gain slot 0. In cascaded control modes this is t
	// he inner loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kI_0 ConfigParam = 14
	//
	// Derivative gain constant for gain slot 0. In cascaded control modes this is
	//  the inner loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kD_0 ConfigParam = 15
	//
	// Feed Forward gain constant for gain slot 0. In cascaded control modes this
	// is the inner loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kF_0 ConfigParam = 16
	//
	// Integrator zone constant for gain slot 0. The PIDF loop integrator will onl
	// y accumulate while the setpoint is within IZone of the target. In cascaded
	//  control modes this is the inner loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kIZone_0 ConfigParam = 17
	//
	// PIDF derivative filter constant for gain slot 0. In cascaded control modes
	// this is the inner loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kDFilter_0 ConfigParam = 18
	//
	// Max output constant for gain slot 0. This is the max output of the controll
	// er as well as the max integrator value. In cascaded control modes this is
	// the inner loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kOutputMin_0 ConfigParam = 19
	//
	// Min output constant for gain slot 0. This is the min output of the controll
	// er as well as the min integrator value. In cascaded control modes this is
	// the inner loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kOutputMax_0 ConfigParam = 20
	//
	// Perportional gain constant for gain slot 1. In cascaded control modes this
	// is the inner loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kP_1 ConfigParam = 21
	//
	// Integral gain constant for gain slot 1. In cascaded control modes this is t
	// he inner loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kI_1 ConfigParam = 22
	//
	// Derivative gain constant for gain slot 1. In cascaded control modes this is
	//  the inner loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kD_1 ConfigParam = 23
	//
	// Feed Forward gain constant for gain slot 1. In cascaded control modes this
	// is the inner loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kF_1 ConfigParam = 24
	//
	// Integrator zone constant for gain slot 1. The PIDF loop integrator will onl
	// y accumulate while the setpoint is within IZone of the target. In cascaded
	//  control modes this is the inner loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kIZone_1 ConfigParam = 25
	//
	// PIDF derivative filter constant for gain slot 1. In cascaded control modes
	// this is the inner loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kDFilter_1 ConfigParam = 26
	//
	// Max output constant for gain slot 1. This is the max output of the controll
	// er as well as the max integrator value. In cascaded control modes this is
	// the inner loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kOutputMin_1 ConfigParam = 27
	//
	// Min output constant for gain slot 1. This is the min output of the controll
	// er as well as the min integrator value. In cascaded control modes this is
	// the inner loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kOutputMax_1 ConfigParam = 28
	//
	// Perportional gain constant for gain slot 3. In cascaded control modes this
	// is the outer loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kP_2 ConfigParam = 29
	//
	// Integral gain constant for gain slot 3. In cascaded control modes this is t
	// he outer loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kI_2 ConfigParam = 30
	//
	// Derivative gain constant for gain slot 3. In cascaded control modes this is
	//  the outer loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kD_2 ConfigParam = 31
	//
	// Feed Forward gain constant for gain slot 3. In cascaded control modes this
	// is the outer loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kF_2 ConfigParam = 32
	//
	// Integrator zone constant for gain slot 3. The PIDF loop integrator will onl
	// y accumulate while the setpoint is within IZone of the target. In cascaded
	//  control modes this is the outer loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kIZone_2 ConfigParam = 33
	//
	// PIDF derivative filter constant for gain slot 3. In cascaded control modes
	// this is the outer loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kDFilter_2 ConfigParam = 34
	//
	// Max output constant for gain slot 3. This is the max output of the controll
	// er as well as the max integrator value. In cascaded control modes this is
	// the outer loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kOutputMin_2 ConfigParam = 35
	//
	// Min output constant for gain slot 3. This is the min output of the controll
	// er as well as the min integrator value. In cascaded control modes this is
	// the outer loop gain slot 0.
	// @default 0
	// @type float32
	ConfigParam_kOutputMax_2 ConfigParam = 36
	//
	// Perportional gain constant for gain slot 4. In cascaded control modes this
	// is the outer loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kP_3 ConfigParam = 37
	//
	// Integral gain constant for gain slot 4. In cascaded control modes this is t
	// he outer loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kI_3 ConfigParam = 38
	//
	// Derivative gain constant for gain slot 4. In cascaded control modes this is
	//  the outer loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kD_3 ConfigParam = 39
	//
	// Feed Forward gain constant for gain slot 4. In cascaded control modes this
	// is the outer loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kF_3 ConfigParam = 40
	//
	// Integrator zone constant for gain slot 4. The PIDF loop integrator will onl
	// y accumulate while the setpoint is within IZone of the target. In cascaded
	//  control modes this is the outer loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kIZone_3 ConfigParam = 41
	//
	// PIDF derivative filter constant for gain slot 4. In cascaded control modes
	// this is the outer loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kDFilter_3 ConfigParam = 42
	//
	// Max output constant for gain slot 4. This is the max output of the controll
	// er as well as the max integrator value. In cascaded control modes this is
	// the outer loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kOutputMin_3 ConfigParam = 43
	//
	// Min output constant for gain slot 4. This is the min output of the controll
	// er as well as the min integrator value. In cascaded control modes this is
	// the outer loop gain slot 1.
	// @default 0
	// @type float32
	ConfigParam_kOutputMax_3 ConfigParam = 44
	//
	// Reserved
	// @default 0
	// @type uint
	ConfigParam_kReserved ConfigParam = 45
	//
	// Simple scalar for all units in all closed loop control modes to scale units
	//  to native. Use this to scale the output to things like gear ratios or uni
	// t conversions
	// @default 1
	// @type float32
	ConfigParam_kOutputRatio ConfigParam = 46
	//
	// Low 32-bits of unique 96-bit serial number
	// @default 0
	// @type uint
	ConfigParam_kSerialNumberLow ConfigParam = 47
	//
	// Middle 32-bits of unique 96-bit serial number
	// @default 0
	// @type uint
	ConfigParam_kSerialNumberMid ConfigParam = 48
	//
	// High 32-bits of unique 96-bit serial number
	// @default 0
	// @type uint
	ConfigParam_kSerialNumberHigh ConfigParam = 49
	//
	// Limit switch polarity. Default is Normally Open (1), and can be set to Norm
	// ally Closed (0)
	// @default 1
	// @type bool
	ConfigParam_kLimitSwitchFwdPolarity ConfigParam = 50
	//
	// Limit switch polarity. Default is Normally Open (1), and can be set to Norm
	// ally Closed (0)
	// @default 1
	// @type bool
	ConfigParam_kLimitSwitchRevPolarity ConfigParam = 51
	//
	// Limit switch enable, disabled by default
	// @default 0
	// @type bool
	ConfigParam_kHardLimitFwdEn ConfigParam = 52
	// sparkusb
	// Limit switch enable, disabled by default
	// @default 0
	// @type bool
	ConfigParam_kHardLimitRevEn ConfigParam = 53
	//
	// Soft limit enable, disabled by default
	// @default 0
	// @type bool
	ConfigParam_kSoftLimitFwdEn ConfigParam = 54
	//
	// Soft limit enable, disabled by default
	// @default 0
	// @type bool
	ConfigParam_kSoftLimitRevEn ConfigParam = 55
	//
	// Voltage ramp rate active for all control modes in V/s, a value of 0 disable
	// s this feature
	// @default 0
	// @type float32
	// @unit V/s
	ConfigParam_kRampRate ConfigParam = 56
	//
	// CAN EXTID of the message with data to follow
	// @default 0
	// @type uint
	ConfigParam_kFollowerID ConfigParam = 57
	//
	// Special configuration register for setting up to follow on a repeating mess
	// age (follower mode). CFG[0] to CFG[3] where CFG[0] is the motor output sta
	// rt bit (LSB), CFG[1] is the motor output stop bit (MSB). CFG[0] - CFG[1] d
	// etermines edieness. CFG[2] bits determine sign mode and inverted, CFG[3] s
	// ets a preconfigured controller (0x1A = REV, 0x1B = Talon/Victor style as o
	// f 2018 season)
	// @default 0
	// @type uint
	ConfigParam_kFollowerConfig ConfigParam = 58
)

var ConfigParam_name = map[int32]string{
	0:  "kCanID",
	1:  "kInputMode",
	2:  "kMotorType",
	3:  "kCommAdvance",
	4:  "kSensorType",
	5:  "kCtrlType",
	6:  "kIdleMode",
	7:  "kInputDeadband",
	8:  "kFirmwareVer",
	9:  "kHallOffset",
	10: "kPolePairs",
	11: "kCurrentChop",
	12: "kCurrentLimit",
	13: "kP_0",
	14: "kI_0",
	15: "kD_0",
	16: "kF_0",
	17: "kIZone_0",
	18: "kDFilter_0",
	19: "kOutputMin_0",
	20: "kOutputMax_0",
	21: "kP_1",
	22: "kI_1",
	23: "kD_1",
	24: "kF_1",
	25: "kIZone_1",
	26: "kDFilter_1",
	27: "kOutputMin_1",
	28: "kOutputMax_1",
	29: "kP_2",
	30: "kI_2",
	31: "kD_2",
	32: "kF_2",
	33: "kIZone_2",
	34: "kDFilter_2",
	35: "kOutputMin_2",
	36: "kOutputMax_2",
	37: "kP_3",
	38: "kI_3",
	39: "kD_3",
	40: "kF_3",
	41: "kIZone_3",
	42: "kDFilter_3",
	43: "kOutputMin_3",
	44: "kOutputMax_3",
	45: "kReserved",
	46: "kOutputRatio",
	47: "kSerialNumberLow",
	48: "kSerialNumberMid",
	49: "kSerialNumberHigh",
	50: "kLimitSwitchFwdPolarity",
	51: "kLimitSwitchRevPolarity",
	52: "kHardLimitFwdEn",
	53: "kHardLimitRevEn",
	54: "kSoftLimitFwdEn",
	55: "kSoftLimitRevEn",
	56: "kRampRate",
	57: "kFollowerID",
	58: "kFollowerConfig",
}
var ConfigParam_value = map[string]int32{
	"kCanID":                  0,
	"kInputMode":              1,
	"kMotorType":              2,
	"kCommAdvance":            3,
	"kSensorType":             4,
	"kCtrlType":               5,
	"kIdleMode":               6,
	"kInputDeadband":          7,
	"kFirmwareVer":            8,
	"kHallOffset":             9,
	"kPolePairs":              10,
	"kCurrentChop":            11,
	"kCurrentLimit":           12,
	"kP_0":                    13,
	"kI_0":                    14,
	"kD_0":                    15,
	"kF_0":                    16,
	"kIZone_0":                17,
	"kDFilter_0":              18,
	"kOutputMin_0":            19,
	"kOutputMax_0":            20,
	"kP_1":                    21,
	"kI_1":                    22,
	"kD_1":                    23,
	"kF_1":                    24,
	"kIZone_1":                25,
	"kDFilter_1":              26,
	"kOutputMin_1":            27,
	"kOutputMax_1":            28,
	"kP_2":                    29,
	"kI_2":                    30,
	"kD_2":                    31,
	"kF_2":                    32,
	"kIZone_2":                33,
	"kDFilter_2":              34,
	"kOutputMin_2":            35,
	"kOutputMax_2":            36,
	"kP_3":                    37,
	"kI_3":                    38,
	"kD_3":                    39,
	"kF_3":                    40,
	"kIZone_3":                41,
	"kDFilter_3":              42,
	"kOutputMin_3":            43,
	"kOutputMax_3":            44,
	"kReserved":               45,
	"kOutputRatio":            46,
	"kSerialNumberLow":        47,
	"kSerialNumberMid":        48,
	"kSerialNumberHigh":       49,
	"kLimitSwitchFwdPolarity": 50,
	"kLimitSwitchRevPolarity": 51,
	"kHardLimitFwdEn":         52,
	"kHardLimitRevEn":         53,
	"kSoftLimitFwdEn":         54,
	"kSoftLimitRevEn":         55,
	"kRampRate":               56,
	"kFollowerID":             57,
	"kFollowerConfig":         58,
}

func (x ConfigParam) String() string {
	return proto.EnumName(ConfigParam_name, int32(x))
}
func (ConfigParam) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

func init() {
	proto.RegisterEnum("sparkmax.MotorType", MotorType_name, MotorType_value)
	proto.RegisterEnum("sparkmax.SensorType", SensorType_name, SensorType_value)
	proto.RegisterEnum("sparkmax.CtrlType", CtrlType_name, CtrlType_value)
	proto.RegisterEnum("sparkmax.IdleMode", IdleMode_name, IdleMode_value)
	proto.RegisterEnum("sparkmax.InputMode", InputMode_name, InputMode_value)
	proto.RegisterEnum("sparkmax.Faults", Faults_name, Faults_value)
	proto.RegisterEnum("sparkmax.ParamType", ParamType_name, ParamType_value)
	proto.RegisterEnum("sparkmax.ParamStatus", ParamStatus_name, ParamStatus_value)
	proto.RegisterEnum("sparkmax.DefinedFollowerID", DefinedFollowerID_name, DefinedFollowerID_value)
	proto.RegisterEnum("sparkmax.FollowerSignMode", FollowerSignMode_name, FollowerSignMode_value)
	proto.RegisterEnum("sparkmax.ConfigParam", ConfigParam_name, ConfigParam_value)
}

func init() { proto.RegisterFile("SPARK-MAX-Types.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 997 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x95, 0x6b, 0x73, 0x1a, 0x37,
	0x14, 0x86, 0xc1, 0x57, 0x90, 0x6f, 0xaf, 0x37, 0x49, 0x73, 0x71, 0xd2, 0xa6, 0xd7, 0xb4, 0xdb,
	0x3a, 0xe5, 0x92, 0x5e, 0xd2, 0x6f, 0x78, 0x81, 0x9a, 0x49, 0xc0, 0x14, 0x3c, 0xae, 0xa7, 0x5f,
	0x18, 0x79, 0x57, 0x18, 0xcd, 0x6a, 0x57, 0x8c, 0x56, 0x80, 0xfd, 0xc3, 0xfa, 0xb3, 0xfa, 0x1f,
	0x3a, 0xd2, 0x2e, 0xee, 0x42, 0xbf, 0xe9, 0xbc, 0x3a, 0x3a, 0x8f, 0xf6, 0xf0, 0x1e, 0x41, 0x9e,
	0x0c, 0xfb, 0x8d, 0xc1, 0x87, 0xd3, 0x6e, 0xe3, 0xfa, 0xf4, 0xf2, 0x7e, 0xca, 0x92, 0xb7, 0x53,
	0x25, 0xb5, 0x74, 0x4a, 0xc9, 0x94, 0xaa, 0x30, 0xa2, 0x77, 0xee, 0x1b, 0x52, 0x8e, 0xa4, 0x96,
	0xca, 0xec, 0x3a, 0x7b, 0x64, 0xf7, 0x4c, 0xcd, 0x92, 0x09, 0x0b, 0x50, 0x70, 0x0e, 0x48, 0xd9,
	0x06, 0x82, 0x25, 0x09, 0x8a, 0xee, 0xef, 0x84, 0x24, 0x2c, 0x4e, 0xb2, 0xcc, 0x7d, 0x52, 0xea,
	0xc9, 0xa1, 0x8d, 0x51, 0x70, 0x0e, 0x09, 0x39, 0xa7, 0x42, 0x64, 0x71, 0xd1, 0xd4, 0x69, 0xc5,
	0xbe, 0x0c, 0x98, 0xc2, 0x86, 0xd9, 0x4c, 0x37, 0x6c, 0xa1, 0x4d, 0xf7, 0x1d, 0x29, 0xf9, 0x5a,
	0x09, 0x5b, 0xe6, 0x80, 0x94, 0x9b, 0x33, 0x7d, 0xef, 0xdd, 0xfb, 0x82, 0xa1, 0x60, 0xaa, 0x5e,
	0x31, 0x21, 0x7d, 0xae, 0xef, 0xd3, 0x2a, 0x57, 0x52, 0x68, 0x7a, 0xcb, 0xb0, 0xe1, 0xbe, 0x26,
	0x25, 0x1e, 0x08, 0xd6, 0x95, 0x01, 0x73, 0xca, 0x64, 0xdb, 0x93, 0x34, 0xd1, 0x28, 0x98, 0xe5,
	0x99, 0xa2, 0x21, 0x43, 0xd1, 0x7d, 0x45, 0xca, 0x3c, 0x9e, 0xce, 0xb4, 0x4d, 0xd9, 0x25, 0x9b,
	0xfd, 0x3f, 0xbb, 0x28, 0x98, 0x85, 0xd7, 0xe8, 0xa1, 0xe8, 0xfe, 0x53, 0x24, 0x3b, 0x63, 0x3a,
	0x13, 0x3a, 0x31, 0x98, 0x33, 0x25, 0x17, 0xb1, 0x9c, 0x99, 0x12, 0x47, 0x64, 0xef, 0x62, 0xce,
	0x94, 0x3f, 0x53, 0x8a, 0xc5, 0x1a, 0xc5, 0xa5, 0x30, 0x5f, 0xb2, 0xcd, 0x17, 0x74, 0x4d, 0x8f,
	0xda, 0xe6, 0x38, 0x36, 0x4d, 0x42, 0xfa, 0x45, 0xa9, 0xb0, 0x65, 0x6e, 0x31, 0xd4, 0x54, 0x08,
	0x6c, 0x9b, 0x2f, 0x6a, 0xb5, 0xfa, 0x83, 0x8b, 0xae, 0x37, 0xf0, 0xb0, 0x63, 0xaf, 0xda, 0xe8,
	0x5d, 0x5e, 0x63, 0x37, 0x5b, 0x0e, 0xae, 0x51, 0x32, 0x17, 0x38, 0xa7, 0xc9, 0x80, 0x25, 0x4c,
	0xa3, 0x6c, 0xa2, 0xe6, 0xe0, 0x2a, 0xad, 0x45, 0x1c, 0x90, 0xfd, 0xa1, 0x1c, 0xeb, 0x8f, 0x3c,
	0xe2, 0xba, 0xbd, 0x08, 0xb0, 0xbf, 0xa2, 0x0c, 0xd8, 0x1c, 0x07, 0x46, 0x39, 0xa7, 0x2a, 0x78,
	0xc8, 0x39, 0x5c, 0x51, 0x4c, 0xce, 0x91, 0xfb, 0x9e, 0x94, 0xa7, 0x54, 0xd1, 0xc8, 0xf6, 0xb9,
	0x4c, 0xb6, 0x79, 0xac, 0xeb, 0x35, 0x14, 0x1c, 0x42, 0x76, 0x66, 0xe9, 0xda, 0x76, 0x78, 0x2c,
	0x24, 0x35, 0xc1, 0x86, 0x53, 0x22, 0x5b, 0x37, 0x52, 0x0a, 0x6c, 0xba, 0x73, 0xb2, 0x67, 0x8f,
	0x0e, 0x35, 0xd5, 0xb3, 0xc4, 0x64, 0xd9, 0xf0, 0xe2, 0x43, 0xea, 0x8a, 0x4e, 0x3c, 0xa7, 0x82,
	0x07, 0x9d, 0x26, 0x8a, 0x86, 0xdb, 0xe5, 0x49, 0x44, 0xb5, 0x3f, 0x31, 0xa0, 0xb4, 0x59, 0x0d,
	0xdf, 0x67, 0x49, 0x62, 0x7e, 0x07, 0x6c, 0x9a, 0xd3, 0xd9, 0x01, 0x6c, 0x39, 0x2f, 0xc9, 0xb3,
	0x9e, 0xd4, 0x9d, 0x68, 0x2a, 0x58, 0xc4, 0x62, 0xcd, 0x82, 0x26, 0x9b, 0x2a, 0xe6, 0x53, 0xcd,
	0x02, 0x6c, 0xbb, 0x13, 0x72, 0x1c, 0xb0, 0x31, 0x8f, 0x59, 0xd0, 0x96, 0x42, 0xc8, 0x05, 0x53,
	0x9d, 0xa6, 0xf3, 0x98, 0x60, 0x19, 0x35, 0x79, 0x42, 0x6f, 0x84, 0x35, 0xa7, 0x43, 0x0e, 0x97,
	0xaa, 0x37, 0x4b, 0xb4, 0x8c, 0xf0, 0x3c, 0x9f, 0x39, 0x34, 0xf6, 0xee, 0xd2, 0x3b, 0xbc, 0x70,
	0x1e, 0x91, 0xa3, 0xa5, 0xda, 0x9f, 0x48, 0x16, 0xf3, 0x3b, 0x9c, 0xb8, 0x7f, 0x10, 0x8c, 0x97,
	0xa9, 0xfc, 0x36, 0xb6, 0x96, 0xc9, 0x95, 0xec, 0x49, 0xa3, 0xa2, 0x90, 0x2f, 0x79, 0xb9, 0x90,
	0x89, 0x27, 0xa3, 0x29, 0x8a, 0xf9, 0x92, 0xf6, 0x34, 0xbd, 0xc5, 0x86, 0xfb, 0xf7, 0x2e, 0xd9,
	0xf3, 0x65, 0x3c, 0xe6, 0xb7, 0x7d, 0xd3, 0x2c, 0xd3, 0xe7, 0xd0, 0xa3, 0x71, 0xa7, 0x99, 0xce,
	0x47, 0xd8, 0x59, 0x7a, 0x13, 0x45, 0x1b, 0x77, 0x97, 0x53, 0x87, 0x0d, 0xd3, 0xc5, 0xd0, 0x93,
	0x51, 0xd4, 0x08, 0xe6, 0x34, 0xf6, 0x59, 0x6a, 0xb1, 0x70, 0xf8, 0x30, 0x6e, 0xd8, 0x32, 0x7d,
	0x0f, 0xbd, 0x6c, 0x6c, 0x52, 0x9b, 0x85, 0x9d, 0x6c, 0x1e, 0xb0, 0x63, 0xee, 0x9e, 0x02, 0x9a,
	0x8c, 0x06, 0x37, 0x34, 0x0e, 0xb0, 0x6b, 0x8b, 0xb6, 0xb9, 0x8a, 0x16, 0x54, 0xb1, 0x2b, 0xa6,
	0x50, 0xb2, 0x45, 0xcd, 0x9c, 0x5e, 0x8c, 0xc7, 0xa9, 0xf3, 0xcc, 0x3d, 0xfa, 0x52, 0xb0, 0x3e,
	0xe5, 0x2a, 0x49, 0xbd, 0x17, 0x7a, 0xe9, 0x1c, 0x78, 0x13, 0x39, 0xc5, 0x9e, 0x73, 0x4c, 0x0e,
	0x96, 0x8a, 0xf5, 0x16, 0xf6, 0x8d, 0x4f, 0xc2, 0xfe, 0xa8, 0x82, 0x03, 0xbb, 0xea, 0x8c, 0x2a,
	0x38, 0xb4, 0xab, 0xe6, 0xa8, 0x82, 0x23, 0xbb, 0x6a, 0x8f, 0x2a, 0x80, 0xb1, 0x75, 0xd8, 0xf9,
	0x4b, 0xc6, 0x6c, 0x54, 0xc1, 0xb1, 0x45, 0x35, 0xdb, 0x5c, 0x68, 0xa6, 0x46, 0x15, 0x38, 0x16,
	0x75, 0x31, 0xd3, 0xa6, 0x27, 0x3c, 0x1e, 0x55, 0xf0, 0x28, 0xaf, 0xd0, 0xbb, 0x51, 0x05, 0x8f,
	0x33, 0x52, 0x15, 0x4f, 0x32, 0x52, 0x15, 0x9f, 0x64, 0xa4, 0x2a, 0x9e, 0x66, 0xa4, 0x2a, 0x9e,
	0xe5, 0x48, 0x55, 0x3c, 0x5f, 0x21, 0x55, 0xf1, 0x62, 0x8d, 0x54, 0xc5, 0xc9, 0x1a, 0xa9, 0x8a,
	0x97, 0x19, 0xa9, 0x86, 0x57, 0x19, 0xa9, 0x86, 0x4f, 0x33, 0x52, 0x0d, 0x9f, 0x65, 0xa4, 0x1a,
	0x5e, 0xe7, 0x48, 0x35, 0x7c, 0xbe, 0x42, 0xaa, 0xe1, 0x8b, 0x35, 0x52, 0x0d, 0x5f, 0xae, 0x91,
	0x6a, 0xf8, 0x2a, 0x23, 0xd5, 0xf1, 0x75, 0x46, 0xaa, 0xe3, 0x9b, 0x8c, 0x54, 0xc7, 0x9b, 0x8c,
	0x54, 0xc7, 0xb7, 0x39, 0x52, 0x1d, 0xdf, 0xad, 0x90, 0xea, 0x70, 0xd7, 0x48, 0x75, 0x7c, 0xbf,
	0x46, 0xaa, 0xe3, 0x07, 0x6b, 0x11, 0xf3, 0xc4, 0xa8, 0x39, 0x0b, 0x70, 0x9a, 0x4b, 0x18, 0x50,
	0xcd, 0x25, 0xde, 0x1a, 0x73, 0x87, 0x43, 0xa6, 0x38, 0x15, 0xbd, 0x59, 0x74, 0xc3, 0xd4, 0x47,
	0xb9, 0xc0, 0x8f, 0xff, 0x53, 0xbb, 0x3c, 0x40, 0xc5, 0x79, 0x42, 0x8e, 0x57, 0xd4, 0x73, 0x7e,
	0x3b, 0x41, 0xd5, 0x39, 0x21, 0x4f, 0x43, 0xeb, 0x8b, 0xe1, 0x82, 0x6b, 0x7f, 0xd2, 0x5e, 0x04,
	0x7d, 0x29, 0xa8, 0x32, 0xef, 0x77, 0x6d, 0x7d, 0x73, 0xc0, 0xe6, 0x0f, 0x9b, 0x75, 0x33, 0x43,
	0x61, 0xfe, 0x0d, 0x6b, 0xc5, 0x78, 0xb7, 0x2a, 0x0e, 0xd8, 0xbc, 0x15, 0xe3, 0x27, 0x2b, 0xe6,
	0x5f, 0xc4, 0x56, 0x8c, 0x9f, 0x57, 0xc5, 0x34, 0xf3, 0x97, 0xf4, 0x8b, 0x69, 0x34, 0x1d, 0x50,
	0xcd, 0xf0, 0xab, 0xb5, 0xfb, 0x7f, 0x0f, 0x09, 0xde, 0xdb, 0x43, 0x0f, 0xaf, 0x86, 0x1d, 0x55,
	0xfc, 0x76, 0xb3, 0x63, 0xff, 0x11, 0xeb, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x51, 0x78, 0x7a,
	0x6b, 0x2a, 0x07, 0x00, 0x00,
}
